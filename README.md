# mst-gql

Bindings for mobx-state-tree and GraphQL

This project can be sponsored through our [open collective](https://opencollective.com/mobx)!

# ‚ö† Warning: experimental project ahead ‚ö†

_This project is an experimental integration between GraphQL and mobx-state-tree. The project will help you to bootstrap mobx-state-tree and graphQL based projects very quickly. However, be aware, there are currently no active maintainers for this project, so we are looking for maintainers that need use project in real life situations and evolve it further!_

To become a maintainer, see: [#1](https://github.com/mobxjs/mst-gql/issues/1) üôè

That being said, it is pretty safe to adopt this project in the sense that just as scaffolding tool it can be pretty beneficial, even if it doesn't cover all cases of your project.

# üöÄ Installation üöÄ

Installation: `yarn add mobx mobx-state-tree mobx-react@6.0.0-rc.4 react react-dom mst-gql`

If you want to use graphql tags, also install: `yarn add graphql graphql-tag`

# üë©‚Äçüéì Why üë©‚Äçüéì

Both GraphQL and mobx-state-tree are model-first driven approaches, so they have a naturally matching architecture. If you are tired of having your data shapes defined in GraphQL, MobX-state-tree and possible TypeScript as well, this project might be a great help!

Furthermore, this project closes the gap between GraphQL and mobx-state-tree as state management solutions. GraphQL is very transport oriented, while MST is great for client side state management. GraphQL clients like apollo do support some form of client-side state, but that is still quite cumbersome compared to the full model driven power unlocked by MST, where local actions, reactive views, and MobX optimized rendering model be used.

Benefits:

- Model oriented
- Type reuse between GraphQL and MobX-state-tree
- Generates types, queries, mutations and subscription code
- Strongly typed (TypeScript). Auto complete all the things!
- Local views, actions, state and model life-cycles
- Automatic instance reuse
- Built-in support for local storage, caching, query caching, subscriptions (over websockets), optimistic updates
- Idiomatic store organization
- Incremental scaffolding that preserves changes

# üëü Overview & getting started üëü

The `mst-gql` libraries consists of two parts:

1. Scaffolding
2. A runtime library

The scaffolder is a compile-time utility that generates a MST store and models based on the type information provided by your endpoint. This utility doesn't just generate models for all your types, but also query, mutation and subscription code base on the data statically available.

The runtime library is configured by the scaffolder, and provides entry points to use the generated generated or hand-written queries, React components, and andditional utilities you want to _mixin_ to your stores.

### Scaffolding

To get started,after [installing](#installation) mst-gql and its dependencies, the first task is to scaffold your store and runtime models based on your graphql endpoint.

To scaffold TypeScript models based on a locally running graphQL endpoint on port 4000, run: `yarn mst-gql --format ts http://localhost:4000/graphql`. There are several additional flags that can be passed to the CLI, which are detailed [below](#cli).

Tip: Note that API descriptions found in the graphQL endpoint will generally end up in the generated code, so make sure to write them!

After running the scaffolder, a bunch of files will be generated in the `src/models/` directory of your project (or whatever path your provided):

- `index` - A barrel file that exposes all intersting things generated
- `RootStore` - The store generated by mst-gql that exposes the following stuff
  - Storage for all "root" types (see below)
  - The `.query`, `.mutate` and `.subscribe` low-level api's to run graphql queries
  - Generated `.queryXXX` ,`.mutateXXX` and `.subscribeXXX` actions based on the query definitions found in your graphQL endpoint
  - Any extensions that you will add to the store!
- Model classes per type found in the graphQL endpoint. These expose the following things:
  - All fields will have been translated into MST equivalents
  - A `.store` back-reference to the owning store
  - A `xxxPrimitives` query fragment, that can be used as selector to obtain all the primitive fields of an object type
  - (TypeScript only) a `type` that describes the runtime type of a model instance. These are useful to type parameters and react component properties
- `reactUtils`. This is a set of utilities to be used in React, exposing the following:
  - `StoreContext`: a strongly typed React context, that can be used to make the `RootStore` available through your app
  - `Query`: A react component that can be used to render queries, mutations etc. It is bound to the `StoreContext` automatically.

For example, the following graphQL schema will generate the store and message as shown below:

```graphql
type User {
  id: ID
  name: String!
  avatar: String!
}
type Message {
  id: ID
  user: User!
  text: String!
}
type Query {
  messages: [Message]
  message(id: ID!): Message
  me: User
}
type Subscription {
  newMessages: Message
}
type Mutation {
  changeName(id: ID!, name: String!): User
}
```

`Message.ts` (shortened):

```typescript
export const Message = MSTGQLObject.named("Message")
  .props({
    __typename: types.optional(types.literal("Message"), "Message"),
    id: types.identifier,
    user: MSTGQLRef(types.late(() => User)),
    text: types.string
  })
  .views(self => ({
    get store() {
      return self.__getStore<typeof RootStore.Type>()
    }
  }))
```

`RootStore.ts` (shortened):

```typescript
export const RootStore = MSTGQLStore.named("RootStore")
  .extend(
    configureStoreMixin(
      [["Message", () => Message], ["User", () => User]],
      ["Message", "User"]
    )
  )
  .props({
    messages: types.optional(types.map(types.late(() => Message)), {}),
    users: types.optional(types.map(types.late(() => User)), {})
  })
  .actions(self => ({
    queryMessages(
      variables?: {},
      resultSelector = messagePrimitives,
      options: QueryOptions = {}
    ) {
      return self.query<typeof Message.Type[]>(
        `query messages { messages {
        ${resultSelector}
      } }`,
        variables,
        options
      )
    },
    queryMessage(
      variables: { id: string },
      resultSelector = messagePrimitives,
      options: QueryOptions = {}
    ) {
      return self.query<typeof Message.Type>(
        `query message($id: ID!) { message(id: $id) {
        ${resultSelector}
      } }`,
        variables,
        options
      )
    },
    queryMe(
      variables?: {},
      resultSelector = userPrimitives,
      options: QueryOptions = {}
    ) {
      return self.query<typeof User.Type>(
        `query me { me {
        ${resultSelector}
      } }`,
        variables,
        options
      )
    },
    mutateChangeName(
      variables: { id: string; name: string },
      resultSelector = userPrimitives,
      optimisticUpdate?: () => void
    ) {
      return self.mutate<typeof User.Type>(
        `mutation changeName($id: ID!, $name: String!) { changeName(id: $id, name: $name) {
        ${resultSelector}
      } }`,
        variables,
        optimisticUpdate
      )
    },
    subscribeNewMessages(variables?: {}, resultSelector = messagePrimitives) {
      return self.subscribe<typeof Message.Type>(
        `subscription newMessages { newMessages {
        ${resultSelector}
      } }`,
        variables
      )
    }
  }))
```

_(Yes, that is a lot of code. A lot of code that you don't have to write üòá)_

Note that the mutations and queries are now strongly typed! The parameters will be type checked, and the return types of the query methods are correct. Nonetheless, you will often write wrapper methods around those generated actions, to, for example, fine the fragments of the result set that should be retrieved

### Initializing the store

To prepare your app to use the `RootStore`, it needs to be initialized, which is pretty straight forward, so here is quick example of what an entry file might look like:

```typescript
// 1
import React from "react"
import * as ReactDOM from "react-dom"
import "./index.css"

import { App } from "./components/App"

// 2
import { createHttpClient } from "mst-gql"
import { RootStore, StoreContext } from "./models"

// 3
const rootStore = RootStore.create(undefined, {
  gqlHttpClient: createHttpClient("http://localhost:4000/graphql")
})

// 4
ReactDOM.render(
  <StoreContext.Provider value={rootStore}>
    <Home />
  </StoreContext.Provider>, document.getElementById("root")
)

// 5
window.store = rootStore
```

1. Typical react stuff, pretty unrelated to this library
2. Bunch of imports that are related to this lib :)
3. When starting our client, we initialize a `rootStore`, which, in typical MST fashion, takes 2 arguments:
   1. The snapshot with the initial state of the client. In this case it is `undefined`, but one could rehydrate server state here, or pick a snapshot from `localStorage`, etc.
   2. The transportation of the store. Either `gqlHttpClient`, `gqlWsClient` or both need to be provided.
4. We initialize rendering. Note that we use `StoreContext.Provider` to make the store available to the rest of the rendering three
5. We expose the store on `window`. This has no practical use, and should be done only in DEV builds. It is a really convenient way to quickly inspect the store, or even fire actions or queries directly from the console of the browser's developer tools. (See this [talk](https://www.youtube.com/watch?v=3J9EJrvqOiM&index=7&t=0s&list=PLW0vzLDjfaNSFs7OBLK6anfQiE5FJzAPD) for some cool benefits of that)

### Loading and rendering your first data

Now, we are ready to write our first React components that use the store!
Because the store is a normal MST store, like usual, `observer` based components can be used to render the contents of the store.

However, mst-sql also provides the [Query component](#query-component) that can be used to track the state of an ongoing query or mutation. It can be used in many different ways (see the details below), but here is a quick example:

```typescript
import React from "react"

import { Error, Loading, Message } from "./"
import { Query } from "../models/reactUtils"

export const Home = () => (
  <Query query={store => store.queryMessages()}>
    {({ store, error, data }) => {
      if (error) return <Error>{error.message}</Error>
      if (loading) return <Loading />
      return (
        <ul>
          {data.map(message => (
              <Message key={message.id} message={message} />
            ))}
        </ul>
      )
    }}
  </Query>
)
```

The `Query` component is imported from the generated `reactUtils`, so that it is bound automatically to the right store.
The `query` property accepts many different types of arguments, but the most convenient one is to give it a callback that invokes one of the query (or your own) methods on the store. 
The [Query object](#query-object) returned from that action will be used to automatically update the rendering.

The `Query` component takes a children function that receives, among other things, the `store`, `loading` and `data` fields.

The `Query` component is a convenience utility, but the lower primitives can also be used manually. 
For example, reactivity is provided by using `observer` from `mobx-react`, and you can manually get the `store` in any component by using for example React's `useContext(StoreContext)`.

### Mutations

Mutations work very similarly to queries. To render a mutation, the `Query` component can be used again.
Except, this time we start without a `query` property, only to set it later when a mutation is started.
For example the following component uses a custom `toggle` action that wraps a graphQL mutation:

```javascript
import * as React from "react"
import { Query } from "../models/reactUtils"

export const Todo = ({ todo }) => (
  <Query>
    {({ setQuery, loading, error }) => (
      <li onClick={() => setQuery(todo.toggle())}>
        <p className={`${todo.complete ? "strikethrough" : ""}`}>{todo.text}</p>
        {error && <span>Failed to update: {error}</span>}
        {loading && <span>(updating)</span>}
      </li>
    )}
  </Query>
)
```

### Optimistic updates

The Todo model used in the above component is defined as follows:

```javascript
/* #region typedef */
export const Todo = MSTGQLObject.named('Todo')
  .props({
    __typename: types.optional(types.literal("Todo"), "Todo"),
    id: types.identifier,
    text: types.optional(types.string, ''),
    complete: types.optional(types.boolean, false),
  })
  .views(self => ({
    get store() {
      return self.__getStore<typeof RootStore.Type>()
    }
  })) 
/* #endregion */
  .actions(self => ({
    toggle() {
      return self.store.mutateToggleTodo({ id: self.id }, undefined, () => {
        self.complete = !self.complete
      })
    }
  }))
```

There are few things to notice:

1. Our `toggle` action wraps around the generated `mutateToggleTodo` mutation, giving us a much more convenient client api
2. The Query object created by `mutateToggleTodo` is returned from our action, so that we can pass it (for example) to the `setQuery` as done in the previous listing.
3. We've set the third argument of the mutation, called `optimisticUpdate`. This function is executed immediately when the mutation is created, without awaiting it's result. So that the change becomes immediately visible in the UI. However, MST will record the [patches](https://github.com/mobxjs/mobx-state-tree#patches). If the mutation fails in the future, any changes made inside this `optimisticUpdate` callback will automatically be rolled back by reverse applying the recorded patches!


### Customizing generated files

All files generated by `mst-gql` consists of several `/* #region */` comments. All code inside a `#region`s is managed by mst-gql. All code outside will be preserved.

Thanks to how MST models [compose](https://github.com/mobxjs/mobx-state-tree#creating-models), this means that you can introduce as many additional `views`, `actions` and `props` as you want to your models, by chaining more calls unto the model definitions. Those actions will often wrap around the generated methods, setting some predefined parameters, or composing the queries into bigger operations.

Exampe of a generated model, that introduces a `toggle` action that wraps around one of the generated mutations:

```javascript
/* This is a mst-sql generated file */

/* #region type-imports */
import { types } from "mobx-state-tree"
import { MSTGQLObject, MSTGQLRef } from "mst-gql"
import { RootStore } from "./index"
/* #endregion */

/* #region fragments */
export const todoPrimitives = `
__typename
id
text
complete
`
/* #endregion */

/* #region type-def */
export type TodoType = typeof Todo.Type

/**
* Todo
*/
export const Todo = MSTGQLObject
  .named('Todo')
  .props({
    __typename: types.optional(types.literal("Todo"), "Todo"),
    id: types.identifier,
    text: types.optional(types.string, ''),
    complete: types.optional(types.boolean, false),
  })
  .views(self => ({
    get store() {
      return self.__getStore<typeof RootStore.Type>()
    }
  }))
/* #endregion */
  .actions(self => ({
    toggle() {
      return self.store.mutateToggleTodo({ id: self.id })
    }
  }))
```

That's it for the introduction!
For the many different ways in which the above can applied in practice, check out the [examples](#examples)

---

# üçø How the store is structured üçø

#### Root types

TODO:

#### references & normalizing

TODO:

---

# ü¶Ñ API ü¶Ñ

## CLI

The `mst-gql` command currently accepts the following arguments:

- `--format ts|js` The type of files that need to be generated (default: `js`)
- `--outDir <dir>` The output directory of the generated files (default: `src/models`)
- `--excludes 'type1,type2,typeN'` The types that should be omitted during generation, as we are not interested in for this app. 
- `--roots 'type1,type2,typeN'` The types that should be used as (root types)[#root-types]
- `source` The last argument is the location at which to find the graphQL definitions. This can be
  - a graphql endpoint, like `http://host/graphql`
  - a graphql files, like `schema.graphql`
  - a parsed graphql file, like `schema.json`

## RootStore

The generated RootStore exposes the following members:

#### `__queryCache`

#### `merge(data)`

#### `rawRequest(query: string, variables: any): Promise`

#### `query(query, variables, options): Query`

#### `mutate(query, variables, optmisticUpdate): Query`

#### `subscribe(query, variables): () => void`

## Models

#### `hasLoaded(field)`

#### `store`

#### `xxxxPrimitives`

#### `xxxxType`

#### QueryOptions

```typescript

export type FetchPolicy =
  | "cache-first" // Use cache if available, avoid network request if possible
  | "cache-only" // Use cache if available, or error
  | "cache-and-network" // Use cache, but still send request and update cache in the background
  | "network-only" // Skip cache, but cache the result
  | "no-cache" // Skip cache, and don't cache the response either

export interface QueryOptions {
  raw?: boolean // If set, the response data is returned verbatim, rather than parsing them into the relevant MST models
  fetchPolicy?: FetchPolicy
}
```

## `createHttpClient(url: string, options: HttpClientOptions = {})`

Creates a http client for transportation purposes. 
For documentation of the options, see: https://github.com/prisma/graphql-request

```typescript
import { createHttpClient } from "mst-gql"
import { RootStore } from "./models/RootStore"

const gqlHttpClient = createHttpClient("http://localhost:4000/graphql")

const rootStore = RootStore.create(undefined, {
  gqlHttpClient
})
```

## Creating a websocket client

Creating a websocket client can be done by using the `subscriptions-transport-ws` package, and passing a client to the store as `gqlWsClient` environment variable:

```typescript
import { SubscriptionClient } from "subscriptions-transport-ws"

import { RootStore } from "./models/RootStore"

const gqlWsClient = new SubscriptionClient("ws://localhost:4001/graphql", {
  reconnect: true
})

const rootStore = RootStore.create(undefined, {
  gqlWsClient
})
```

### Query object


export class Query<T = unknown> implements PromiseLike<T> {
  loading = false
  data: T | undefined = undefined
  error: any = undefined

  refetch = (): Promise<T> => {

  case<R>(handlers: CaseHandlers<T, R>): R {

  currentPromise() 

  then



## Query component

```typescript
export type QueryLike<STORE, DATA> =
  | ((store: STORE) => Query<DATA>)
  | Query<DATA>
  | string
  | DocumentNode

export type QueryProps<STORE, DATA> = {
  store?: STORE
  query?: QueryLike<STORE, DATA>
  variables?: any
  children: (args: {
    store: STORE
    loading: boolean
    error: any
    data: DATA | undefined
    prevData: DATA | undefined // set of previously fetched values, in case the query was replaced
    query: Query<DATA> | undefined
    setQuery: (query: QueryLike<STORE, DATA>) => void
  }) => React.ReactElement
}
```


## `StoreContext`



# Tips & tricks

TODO:

Data is plain, rather than mst object -> make sure your query includes \_\_typename

Data is MST object, but not merged with the store state -> mase sure your query includes id

Should scaffolded files be generated

Fold sections in VSCode with this [extension](https://marketplace.visualstudio.com/items?itemName=maptz.regionfolder)

Withstore like in example 4

Using getters / setters in views for foreign keys

using mutations, see BookTrips component

# üôà Examples üôà

Before running the examples, run the following in the root directory:

```
yarn install
yarn prepare-examples
```

All examples start on url http://localhost:3000/

Overview of the examples:

TODO:

1.
2.
3.
4.
5.
6.

Basic http / mst-sql classes / optimistic update

Scaffolding

webservices, scaffolded classes

more in depth example TODO: create diff branch / MR link with the changes

# üí• Roadmap üí•

- [ ] implement example 5 / add prisma demo with standardized api's
- [ ] clean up readme example
- [ ] tests
- [ ] fix tests in the examples
- [ ] create PR to show diff on the apollo example
- [ ] CI
- [ ] clean up / beautify example 5-todos
- [ ] clean up rootstore in apollo example, many queries are now defined twice

#### Quite random iddeas

- [ ] Don't generate queries / mutations into the root store, but as static utilities, so that unused ones can be tree-shaken away
- [ ] automatically insert \_\_typename in gql tag queries, like apollo client does
- [ ] package react stuff separately, add `--no-react` flag to CLI
- [ ] add // prettier, eslint ignore comments
- [ ] support a config file instead of CLI args
- [ ] auto load / auto save?
- [ ] offline actions?
- [ ] use apollo client / urql instead of grapqhl-request as back-end?
- [ ] be able to specify ownership between types?
- [ ] add post run comment option to cli, to run e.g. prettier / eslint --fix ?
- [ ] generate generation data + mst-sql version into file headers
- [ ] Lerna for simpler repo setup
- [ ] add support for identifier attributes not called \_id
