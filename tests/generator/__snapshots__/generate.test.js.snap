// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`basic scaffolding to work 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "UserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * UserBase
 * auto generated base class for the model UserModel.
 */
export const UserModelBase = ModelBase
  .named('User')
  .props({
    __typename: types.optional(types.literal(\\"User\\"), \\"User\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.string),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class UserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
}
export function selectFromUser() {
  return new UserModelSelector()
}

export const userModelPrimitives = selectFromUser().name.avatar
",
    true,
  ],
  Array [
    "UserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { UserModelBase } from \\"./UserModel.base\\"

/* The TypeScript type of an instance of UserModel */
export interface UserModelType extends Instance<typeof UserModel.Type> {}

/* A graphql query fragment builders for UserModel */
export { selectFromUser, userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

/**
 * UserModel
 */
export const UserModel = UserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { UserModel, UserModelType } from \\"./UserModel\\"
import { userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  users: ObservableMap<string, UserModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['User', () => UserModel]], ['User']))
  .props({
    users: types.optional(types.map(types.late((): any => UserModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: UserModelSelector) => UserModelSelector) = userModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: UserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new UserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./UserModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`basic scaffolding with js naming convention, specific query type to work 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "QueryRootModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { MyUserModelSelector } from \\"./MyUserModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  me: MyUserModelType;
}

/**
 * QueryRootBase
 * auto generated base class for the model QueryRootModel.
 */
export const QueryRootModelBase = withTypedRefs<Refs>()(ModelBase
  .named('QueryRoot')
  .props({
    __typename: types.optional(types.literal(\\"query_root\\"), \\"query_root\\"),
    me: types.union(types.undefined, types.null, MSTGQLRef(types.late((): any => MyUserModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class QueryRootModelSelector extends QueryBuilder {
  me(builder?: string | MyUserModelSelector | ((selector: MyUserModelSelector) => MyUserModelSelector)) { return this.__child(\`me\`, MyUserModelSelector, builder) }
}
export function selectFromQueryRoot() {
  return new QueryRootModelSelector()
}

export const queryRootModelPrimitives = selectFromQueryRoot()
",
    true,
  ],
  Array [
    "QueryRootModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { QueryRootModelBase } from \\"./QueryRootModel.base\\"

/* The TypeScript type of an instance of QueryRootModel */
export interface QueryRootModelType extends Instance<typeof QueryRootModel.Type> {}

/* A graphql query fragment builders for QueryRootModel */
export { selectFromQueryRoot, queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"

/**
 * QueryRootModel
 */
export const QueryRootModel = QueryRootModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "MyUserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { IObservableArray } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  emptyBoxes: IObservableArray<PossiblyEmptyBoxModelType>;
}

/**
 * MyUserBase
 * auto generated base class for the model MyUserModel.
 */
export const MyUserModelBase = withTypedRefs<Refs>()(ModelBase
  .named('MyUser')
  .props({
    __typename: types.optional(types.literal(\\"my_user\\"), \\"my_user\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.string),
    emptyBoxes: types.union(types.undefined, types.array(types.union(types.null, MSTGQLRef(types.late((): any => PossiblyEmptyBoxModel))))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class MyUserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  emptyBoxes(builder?: string | PossiblyEmptyBoxModelSelector | ((selector: PossiblyEmptyBoxModelSelector) => PossiblyEmptyBoxModelSelector)) { return this.__child(\`emptyBoxes\`, PossiblyEmptyBoxModelSelector, builder) }
}
export function selectFromMyUser() {
  return new MyUserModelSelector()
}

export const myUserModelPrimitives = selectFromMyUser().name.avatar
",
    true,
  ],
  Array [
    "MyUserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { MyUserModelBase } from \\"./MyUserModel.base\\"

/* The TypeScript type of an instance of MyUserModel */
export interface MyUserModelType extends Instance<typeof MyUserModel.Type> {}

/* A graphql query fragment builders for MyUserModel */
export { selectFromMyUser, myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"

/**
 * MyUserModel
 */
export const MyUserModel = MyUserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "PossiblyEmptyBoxModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * PossiblyEmptyBoxBase
 * auto generated base class for the model PossiblyEmptyBoxModel.
 */
export const PossiblyEmptyBoxModelBase = ModelBase
  .named('PossiblyEmptyBox')
  .props({
    __typename: types.optional(types.literal(\\"possibly_empty_box\\"), \\"possibly_empty_box\\"),
    id: types.identifier,
    label: types.union(types.undefined, types.string),
    isEmpty: types.union(types.undefined, types.boolean),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class PossiblyEmptyBoxModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get label() { return this.__attr(\`label\`) }
  get isEmpty() { return this.__attr(\`isEmpty\`) }
}
export function selectFromPossiblyEmptyBox() {
  return new PossiblyEmptyBoxModelSelector()
}

export const possiblyEmptyBoxModelPrimitives = selectFromPossiblyEmptyBox().label.isEmpty
",
    true,
  ],
  Array [
    "PossiblyEmptyBoxModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { PossiblyEmptyBoxModelBase } from \\"./PossiblyEmptyBoxModel.base\\"

/* The TypeScript type of an instance of PossiblyEmptyBoxModel */
export interface PossiblyEmptyBoxModelType extends Instance<typeof PossiblyEmptyBoxModel.Type> {}

/* A graphql query fragment builders for PossiblyEmptyBoxModel */
export { selectFromPossiblyEmptyBox, possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"

/**
 * PossiblyEmptyBoxModel
 */
export const PossiblyEmptyBoxModel = PossiblyEmptyBoxModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { QueryRootModel, QueryRootModelType } from \\"./QueryRootModel\\"
import { queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  myUsers: ObservableMap<string, MyUserModelType>,
  possiblyEmptyBoxes: ObservableMap<string, PossiblyEmptyBoxModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['query_root', () => QueryRootModel], ['my_user', () => MyUserModel], ['possibly_empty_box', () => PossiblyEmptyBoxModel]], ['my_user', 'possibly_empty_box'], \\"js\\"))
  .props({
    myUsers: types.optional(types.map(types.late((): any => MyUserModel)), {}),
    possiblyEmptyBoxes: types.optional(types.map(types.late((): any => PossiblyEmptyBoxModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: MyUserModelSelector) => MyUserModelSelector) = myUserModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: MyUserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new MyUserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./QueryRootModel\\"
export * from \\"./MyUserModel\\"
export * from \\"./PossiblyEmptyBoxModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`basic scaffolding with mandatory fields when the field type is a LIST 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "QueryRootModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { MyUserModelSelector } from \\"./MyUserModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  me: MyUserModelType;
}

/**
 * QueryRootBase
 * auto generated base class for the model QueryRootModel.
 */
export const QueryRootModelBase = withTypedRefs<Refs>()(ModelBase
  .named('QueryRoot')
  .props({
    __typename: types.optional(types.literal(\\"query_root\\"), \\"query_root\\"),
    me: types.union(types.undefined, types.null, MSTGQLRef(types.late((): any => MyUserModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class QueryRootModelSelector extends QueryBuilder {
  me(builder?: string | MyUserModelSelector | ((selector: MyUserModelSelector) => MyUserModelSelector)) { return this.__child(\`me\`, MyUserModelSelector, builder) }
}
export function selectFromQueryRoot() {
  return new QueryRootModelSelector()
}

export const queryRootModelPrimitives = selectFromQueryRoot()
",
    true,
  ],
  Array [
    "QueryRootModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { QueryRootModelBase } from \\"./QueryRootModel.base\\"

/* The TypeScript type of an instance of QueryRootModel */
export interface QueryRootModelType extends Instance<typeof QueryRootModel.Type> {}

/* A graphql query fragment builders for QueryRootModel */
export { selectFromQueryRoot, queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"

/**
 * QueryRootModel
 */
export const QueryRootModel = QueryRootModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "MyUserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { IObservableArray } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  emptyBoxes: IObservableArray<PossiblyEmptyBoxModelType>;
}

/**
 * MyUserBase
 * auto generated base class for the model MyUserModel.
 */
export const MyUserModelBase = withTypedRefs<Refs>()(ModelBase
  .named('MyUser')
  .props({
    __typename: types.optional(types.literal(\\"my_user\\"), \\"my_user\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.array(types.string)),
    emptyBoxes: types.union(types.undefined, types.array(types.union(types.null, MSTGQLRef(types.late((): any => PossiblyEmptyBoxModel))))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class MyUserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  emptyBoxes(builder?: string | PossiblyEmptyBoxModelSelector | ((selector: PossiblyEmptyBoxModelSelector) => PossiblyEmptyBoxModelSelector)) { return this.__child(\`emptyBoxes\`, PossiblyEmptyBoxModelSelector, builder) }
}
export function selectFromMyUser() {
  return new MyUserModelSelector()
}

export const myUserModelPrimitives = selectFromMyUser().name.avatar
",
    true,
  ],
  Array [
    "MyUserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { MyUserModelBase } from \\"./MyUserModel.base\\"

/* The TypeScript type of an instance of MyUserModel */
export interface MyUserModelType extends Instance<typeof MyUserModel.Type> {}

/* A graphql query fragment builders for MyUserModel */
export { selectFromMyUser, myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"

/**
 * MyUserModel
 */
export const MyUserModel = MyUserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "PossiblyEmptyBoxModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * PossiblyEmptyBoxBase
 * auto generated base class for the model PossiblyEmptyBoxModel.
 */
export const PossiblyEmptyBoxModelBase = ModelBase
  .named('PossiblyEmptyBox')
  .props({
    __typename: types.optional(types.literal(\\"possibly_empty_box\\"), \\"possibly_empty_box\\"),
    id: types.identifier,
    label: types.union(types.undefined, types.string),
    isEmpty: types.union(types.undefined, types.boolean),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class PossiblyEmptyBoxModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get label() { return this.__attr(\`label\`) }
  get isEmpty() { return this.__attr(\`isEmpty\`) }
}
export function selectFromPossiblyEmptyBox() {
  return new PossiblyEmptyBoxModelSelector()
}

export const possiblyEmptyBoxModelPrimitives = selectFromPossiblyEmptyBox().label.isEmpty
",
    true,
  ],
  Array [
    "PossiblyEmptyBoxModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { PossiblyEmptyBoxModelBase } from \\"./PossiblyEmptyBoxModel.base\\"

/* The TypeScript type of an instance of PossiblyEmptyBoxModel */
export interface PossiblyEmptyBoxModelType extends Instance<typeof PossiblyEmptyBoxModel.Type> {}

/* A graphql query fragment builders for PossiblyEmptyBoxModel */
export { selectFromPossiblyEmptyBox, possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"

/**
 * PossiblyEmptyBoxModel
 */
export const PossiblyEmptyBoxModel = PossiblyEmptyBoxModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { QueryRootModel, QueryRootModelType } from \\"./QueryRootModel\\"
import { queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  myUsers: ObservableMap<string, MyUserModelType>,
  possiblyEmptyBoxes: ObservableMap<string, PossiblyEmptyBoxModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['query_root', () => QueryRootModel], ['my_user', () => MyUserModel], ['possibly_empty_box', () => PossiblyEmptyBoxModel]], ['my_user', 'possibly_empty_box'], \\"js\\"))
  .props({
    myUsers: types.optional(types.map(types.late((): any => MyUserModel)), {}),
    possiblyEmptyBoxes: types.optional(types.map(types.late((): any => PossiblyEmptyBoxModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: MyUserModelSelector) => MyUserModelSelector) = myUserModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: MyUserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new MyUserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./QueryRootModel\\"
export * from \\"./MyUserModel\\"
export * from \\"./PossiblyEmptyBoxModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`basic scaffolding with mandatory fields when the field type is a OBJECT 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "QueryRootModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { MyUserModelSelector } from \\"./MyUserModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  me: MyUserModelType;
}

/**
 * QueryRootBase
 * auto generated base class for the model QueryRootModel.
 */
export const QueryRootModelBase = withTypedRefs<Refs>()(ModelBase
  .named('QueryRoot')
  .props({
    __typename: types.optional(types.literal(\\"query_root\\"), \\"query_root\\"),
    me: types.union(types.undefined, types.null, MSTGQLRef(types.late((): any => MyUserModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class QueryRootModelSelector extends QueryBuilder {
  me(builder?: string | MyUserModelSelector | ((selector: MyUserModelSelector) => MyUserModelSelector)) { return this.__child(\`me\`, MyUserModelSelector, builder) }
}
export function selectFromQueryRoot() {
  return new QueryRootModelSelector()
}

export const queryRootModelPrimitives = selectFromQueryRoot()
",
    true,
  ],
  Array [
    "QueryRootModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { QueryRootModelBase } from \\"./QueryRootModel.base\\"

/* The TypeScript type of an instance of QueryRootModel */
export interface QueryRootModelType extends Instance<typeof QueryRootModel.Type> {}

/* A graphql query fragment builders for QueryRootModel */
export { selectFromQueryRoot, queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"

/**
 * QueryRootModel
 */
export const QueryRootModel = QueryRootModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "MyUserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  emptyBox: PossiblyEmptyBoxModelType;
}

/**
 * MyUserBase
 * auto generated base class for the model MyUserModel.
 */
export const MyUserModelBase = withTypedRefs<Refs>()(ModelBase
  .named('MyUser')
  .props({
    __typename: types.optional(types.literal(\\"my_user\\"), \\"my_user\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.array(types.string)),
    emptyBox: types.union(types.undefined, MSTGQLRef(types.late((): any => PossiblyEmptyBoxModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class MyUserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  emptyBox(builder?: string | PossiblyEmptyBoxModelSelector | ((selector: PossiblyEmptyBoxModelSelector) => PossiblyEmptyBoxModelSelector)) { return this.__child(\`emptyBox\`, PossiblyEmptyBoxModelSelector, builder) }
}
export function selectFromMyUser() {
  return new MyUserModelSelector()
}

export const myUserModelPrimitives = selectFromMyUser().name.avatar
",
    true,
  ],
  Array [
    "MyUserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { MyUserModelBase } from \\"./MyUserModel.base\\"

/* The TypeScript type of an instance of MyUserModel */
export interface MyUserModelType extends Instance<typeof MyUserModel.Type> {}

/* A graphql query fragment builders for MyUserModel */
export { selectFromMyUser, myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"

/**
 * MyUserModel
 */
export const MyUserModel = MyUserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "PossiblyEmptyBoxModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * PossiblyEmptyBoxBase
 * auto generated base class for the model PossiblyEmptyBoxModel.
 */
export const PossiblyEmptyBoxModelBase = ModelBase
  .named('PossiblyEmptyBox')
  .props({
    __typename: types.optional(types.literal(\\"possibly_empty_box\\"), \\"possibly_empty_box\\"),
    id: types.identifier,
    label: types.union(types.undefined, types.string),
    isEmpty: types.union(types.undefined, types.boolean),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class PossiblyEmptyBoxModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get label() { return this.__attr(\`label\`) }
  get isEmpty() { return this.__attr(\`isEmpty\`) }
}
export function selectFromPossiblyEmptyBox() {
  return new PossiblyEmptyBoxModelSelector()
}

export const possiblyEmptyBoxModelPrimitives = selectFromPossiblyEmptyBox().label.isEmpty
",
    true,
  ],
  Array [
    "PossiblyEmptyBoxModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { PossiblyEmptyBoxModelBase } from \\"./PossiblyEmptyBoxModel.base\\"

/* The TypeScript type of an instance of PossiblyEmptyBoxModel */
export interface PossiblyEmptyBoxModelType extends Instance<typeof PossiblyEmptyBoxModel.Type> {}

/* A graphql query fragment builders for PossiblyEmptyBoxModel */
export { selectFromPossiblyEmptyBox, possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"

/**
 * PossiblyEmptyBoxModel
 */
export const PossiblyEmptyBoxModel = PossiblyEmptyBoxModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { QueryRootModel, QueryRootModelType } from \\"./QueryRootModel\\"
import { queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  myUsers: ObservableMap<string, MyUserModelType>,
  possiblyEmptyBoxes: ObservableMap<string, PossiblyEmptyBoxModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['query_root', () => QueryRootModel], ['my_user', () => MyUserModel], ['possibly_empty_box', () => PossiblyEmptyBoxModel]], ['my_user', 'possibly_empty_box'], \\"js\\"))
  .props({
    myUsers: types.optional(types.map(types.late((): any => MyUserModel)), {}),
    possiblyEmptyBoxes: types.optional(types.map(types.late((): any => PossiblyEmptyBoxModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: MyUserModelSelector) => MyUserModelSelector) = myUserModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: MyUserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new MyUserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./QueryRootModel\\"
export * from \\"./MyUserModel\\"
export * from \\"./PossiblyEmptyBoxModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`basic scaffolding with mandatory fields when the field type is a SCALAR 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "QueryRootModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { MyUserModelSelector } from \\"./MyUserModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  me: MyUserModelType;
}

/**
 * QueryRootBase
 * auto generated base class for the model QueryRootModel.
 */
export const QueryRootModelBase = withTypedRefs<Refs>()(ModelBase
  .named('QueryRoot')
  .props({
    __typename: types.optional(types.literal(\\"query_root\\"), \\"query_root\\"),
    me: types.union(types.undefined, types.null, MSTGQLRef(types.late((): any => MyUserModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class QueryRootModelSelector extends QueryBuilder {
  me(builder?: string | MyUserModelSelector | ((selector: MyUserModelSelector) => MyUserModelSelector)) { return this.__child(\`me\`, MyUserModelSelector, builder) }
}
export function selectFromQueryRoot() {
  return new QueryRootModelSelector()
}

export const queryRootModelPrimitives = selectFromQueryRoot()
",
    true,
  ],
  Array [
    "QueryRootModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { QueryRootModelBase } from \\"./QueryRootModel.base\\"

/* The TypeScript type of an instance of QueryRootModel */
export interface QueryRootModelType extends Instance<typeof QueryRootModel.Type> {}

/* A graphql query fragment builders for QueryRootModel */
export { selectFromQueryRoot, queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"

/**
 * QueryRootModel
 */
export const QueryRootModel = QueryRootModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "MyUserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { IObservableArray } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLRef, QueryBuilder, withTypedRefs } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"
import { RootStoreType } from \\"./index\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  emptyBoxes: IObservableArray<PossiblyEmptyBoxModelType>;
}

/**
 * MyUserBase
 * auto generated base class for the model MyUserModel.
 */
export const MyUserModelBase = withTypedRefs<Refs>()(ModelBase
  .named('MyUser')
  .props({
    __typename: types.optional(types.literal(\\"my_user\\"), \\"my_user\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.array(types.string)),
    emptyBoxes: types.union(types.undefined, types.array(types.union(types.null, MSTGQLRef(types.late((): any => PossiblyEmptyBoxModel))))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  })))

export class MyUserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  emptyBoxes(builder?: string | PossiblyEmptyBoxModelSelector | ((selector: PossiblyEmptyBoxModelSelector) => PossiblyEmptyBoxModelSelector)) { return this.__child(\`emptyBoxes\`, PossiblyEmptyBoxModelSelector, builder) }
}
export function selectFromMyUser() {
  return new MyUserModelSelector()
}

export const myUserModelPrimitives = selectFromMyUser().name.avatar
",
    true,
  ],
  Array [
    "MyUserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { MyUserModelBase } from \\"./MyUserModel.base\\"

/* The TypeScript type of an instance of MyUserModel */
export interface MyUserModelType extends Instance<typeof MyUserModel.Type> {}

/* A graphql query fragment builders for MyUserModel */
export { selectFromMyUser, myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"

/**
 * MyUserModel
 */
export const MyUserModel = MyUserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "PossiblyEmptyBoxModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * PossiblyEmptyBoxBase
 * auto generated base class for the model PossiblyEmptyBoxModel.
 */
export const PossiblyEmptyBoxModelBase = ModelBase
  .named('PossiblyEmptyBox')
  .props({
    __typename: types.optional(types.literal(\\"possibly_empty_box\\"), \\"possibly_empty_box\\"),
    id: types.identifier,
    label: types.union(types.undefined, types.string),
    isEmpty: types.union(types.undefined, types.boolean),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class PossiblyEmptyBoxModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get label() { return this.__attr(\`label\`) }
  get isEmpty() { return this.__attr(\`isEmpty\`) }
}
export function selectFromPossiblyEmptyBox() {
  return new PossiblyEmptyBoxModelSelector()
}

export const possiblyEmptyBoxModelPrimitives = selectFromPossiblyEmptyBox().label.isEmpty
",
    true,
  ],
  Array [
    "PossiblyEmptyBoxModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { PossiblyEmptyBoxModelBase } from \\"./PossiblyEmptyBoxModel.base\\"

/* The TypeScript type of an instance of PossiblyEmptyBoxModel */
export interface PossiblyEmptyBoxModelType extends Instance<typeof PossiblyEmptyBoxModel.Type> {}

/* A graphql query fragment builders for PossiblyEmptyBoxModel */
export { selectFromPossiblyEmptyBox, possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"

/**
 * PossiblyEmptyBoxModel
 */
export const PossiblyEmptyBoxModel = PossiblyEmptyBoxModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { QueryRootModel, QueryRootModelType } from \\"./QueryRootModel\\"
import { queryRootModelPrimitives, QueryRootModelSelector } from \\"./QueryRootModel.base\\"
import { MyUserModel, MyUserModelType } from \\"./MyUserModel\\"
import { myUserModelPrimitives, MyUserModelSelector } from \\"./MyUserModel.base\\"
import { PossiblyEmptyBoxModel, PossiblyEmptyBoxModelType } from \\"./PossiblyEmptyBoxModel\\"
import { possiblyEmptyBoxModelPrimitives, PossiblyEmptyBoxModelSelector } from \\"./PossiblyEmptyBoxModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  myUsers: ObservableMap<string, MyUserModelType>,
  possiblyEmptyBoxes: ObservableMap<string, PossiblyEmptyBoxModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['query_root', () => QueryRootModel], ['my_user', () => MyUserModel], ['possibly_empty_box', () => PossiblyEmptyBoxModel]], ['my_user', 'possibly_empty_box'], \\"js\\"))
  .props({
    myUsers: types.optional(types.map(types.late((): any => MyUserModel)), {}),
    possiblyEmptyBoxes: types.optional(types.map(types.late((): any => PossiblyEmptyBoxModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: MyUserModelSelector) => MyUserModelSelector) = myUserModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: MyUserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new MyUserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./QueryRootModel\\"
export * from \\"./MyUserModel\\"
export * from \\"./PossiblyEmptyBoxModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`enums ending in Enum doesn't have an extra Enum postfix with namingConvention=asis 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "UserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RoleEnumModel } from \\"./RoleEnumModel\\"
import { RootStoreType } from \\"./index\\"
import { interest_enumModel } from \\"./interest_enumModel\\"


/**
 * UserBase
 * auto generated base class for the model UserModel.
 */
export const UserModelBase = ModelBase
  .named('User')
  .props({
    __typename: types.optional(types.literal(\\"User\\"), \\"User\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.string),
    role: types.union(types.undefined, RoleEnumModel),
    interest: types.union(types.undefined, interest_enumModel),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class UserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  get role() { return this.__attr(\`role\`) }
  get interest() { return this.__attr(\`interest\`) }
}
export function selectFromUser() {
  return new UserModelSelector()
}

export const userModelPrimitives = selectFromUser().name.avatar.role.interest
",
    true,
  ],
  Array [
    "UserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { UserModelBase } from \\"./UserModel.base\\"

/* The TypeScript type of an instance of UserModel */
export interface UserModelType extends Instance<typeof UserModel.Type> {}

/* A graphql query fragment builders for UserModel */
export { selectFromUser, userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

/**
 * UserModel
 */
export const UserModel = UserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RoleEnumModel",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { types } from \\"mobx-state-tree\\"

/**
 * Typescript enum
 */

export enum Role {
  USER=\\"USER\\",
ADMIN=\\"ADMIN\\",
AUTHOR=\\"AUTHOR\\"
}

/**
* Role
*/
export const RoleEnumModel = types.enumeration(\\"Role\\", [
        \\"USER\\",
  \\"ADMIN\\",
  \\"AUTHOR\\",
      ])
",
    true,
  ],
  Array [
    "interest_enumModel",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { types } from \\"mobx-state-tree\\"

/**
 * Typescript enum
 */

export enum interest_enum {
  READING=\\"READING\\",
SPORTS=\\"SPORTS\\",
COOKING=\\"COOKING\\"
}

/**
* interest_enum
*/
export const interest_enumModel = types.enumeration(\\"interest_enum\\", [
        \\"READING\\",
  \\"SPORTS\\",
  \\"COOKING\\",
      ])
",
    true,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { UserModel, UserModelType } from \\"./UserModel\\"
import { userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

import { Role } from \\"./RoleEnumModel\\"
import { interest_enum } from \\"./interest_enumModel\\"

/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  users: ObservableMap<string, UserModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['User', () => UserModel]], ['User']))
  .props({
    users: types.optional(types.map(types.late((): any => UserModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: UserModelSelector) => UserModelSelector) = userModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: UserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new UserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./UserModel\\"
export * from \\"./RoleEnumModel\\"
export * from \\"./interest_enumModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`enums ending in Enum doesn't have an extra Enum postfix with namingConvention=js 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "UserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { InterestEnumModel } from \\"./InterestEnumModel\\"
import { RoleEnumModel } from \\"./RoleEnumModel\\"
import { RootStoreType } from \\"./index\\"


/**
 * UserBase
 * auto generated base class for the model UserModel.
 */
export const UserModelBase = ModelBase
  .named('User')
  .props({
    __typename: types.optional(types.literal(\\"User\\"), \\"User\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.string),
    role: types.union(types.undefined, RoleEnumModel),
    interest: types.union(types.undefined, InterestEnumModel),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class UserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
  get role() { return this.__attr(\`role\`) }
  get interest() { return this.__attr(\`interest\`) }
}
export function selectFromUser() {
  return new UserModelSelector()
}

export const userModelPrimitives = selectFromUser().name.avatar.role.interest
",
    true,
  ],
  Array [
    "UserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { UserModelBase } from \\"./UserModel.base\\"

/* The TypeScript type of an instance of UserModel */
export interface UserModelType extends Instance<typeof UserModel.Type> {}

/* A graphql query fragment builders for UserModel */
export { selectFromUser, userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

/**
 * UserModel
 */
export const UserModel = UserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RoleEnumModel",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { types } from \\"mobx-state-tree\\"

/**
 * Typescript enum
 */

export enum Role {
  USER=\\"USER\\",
ADMIN=\\"ADMIN\\",
AUTHOR=\\"AUTHOR\\"
}

/**
* Role
*/
export const RoleEnumModel = types.enumeration(\\"Role\\", [
        \\"USER\\",
  \\"ADMIN\\",
  \\"AUTHOR\\",
      ])
",
    true,
  ],
  Array [
    "InterestEnumModel",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { types } from \\"mobx-state-tree\\"

/**
 * Typescript enum
 */

export enum InterestEnum {
  READING=\\"READING\\",
SPORTS=\\"SPORTS\\",
COOKING=\\"COOKING\\"
}

/**
* InterestEnum
*/
export const InterestEnumModel = types.enumeration(\\"InterestEnum\\", [
        \\"READING\\",
  \\"SPORTS\\",
  \\"COOKING\\",
      ])
",
    true,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { UserModel, UserModelType } from \\"./UserModel\\"
import { userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

import { Role } from \\"./RoleEnumModel\\"
import { InterestEnum } from \\"./InterestEnumModel\\"

/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  users: ObservableMap<string, UserModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['User', () => UserModel]], ['User'], \\"js\\"))
  .props({
    users: types.optional(types.map(types.late((): any => UserModel)), {})
  })
  .actions(self => ({
    queryMe(variables?: {  }, resultSelector: string | ((qb: UserModelSelector) => UserModelSelector) = userModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ me: UserModelType}>(\`query me { me {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new UserModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./UserModel\\"
export * from \\"./RoleEnumModel\\"
export * from \\"./InterestEnumModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`interface field type to work 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "RepoModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { OrganizationModel } from \\"./OrganizationModel\\"
import { OwnerModelSelector } from \\"./OwnerModelSelector\\"
import { UserModel } from \\"./UserModel\\"
import { RootStoreType } from \\"./index\\"


/**
 * RepoBase
 * auto generated base class for the model RepoModel.
 */
export const RepoModelBase = ModelBase
  .named('Repo')
  .props({
    __typename: types.optional(types.literal(\\"Repo\\"), \\"Repo\\"),
    id: types.identifier,
    owner: types.union(types.undefined, types.null, types.union(types.late(() => UserModel), types.late(() => OrganizationModel))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class RepoModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  owner(builder?: string | OwnerModelSelector | ((selector: OwnerModelSelector) => OwnerModelSelector)) { return this.__child(\`owner\`, OwnerModelSelector, builder) }
}
export function selectFromRepo() {
  return new RepoModelSelector()
}

export const repoModelPrimitives = selectFromRepo()
",
    true,
  ],
  Array [
    "RepoModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { RepoModelBase } from \\"./RepoModel.base\\"

/* The TypeScript type of an instance of RepoModel */
export interface RepoModelType extends Instance<typeof RepoModel.Type> {}

/* A graphql query fragment builders for RepoModel */
export { selectFromRepo, repoModelPrimitives, RepoModelSelector } from \\"./RepoModel.base\\"

/**
 * RepoModel
 */
export const RepoModel = RepoModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "OwnerModelSelector",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { QueryBuilder } from \\"mst-gql\\"
import { OrganizationModelSelector } from \\"./OrganizationModel.base\\"
import { UserModelSelector } from \\"./UserModel.base\\"

export class OwnerModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  user(builder?: string | UserModelSelector | ((selector: UserModelSelector) => UserModelSelector)) { return this.__inlineFragment(\`User\`, UserModelSelector, builder) }
  organization(builder?: string | OrganizationModelSelector | ((selector: OrganizationModelSelector) => OrganizationModelSelector)) { return this.__inlineFragment(\`Organization\`, OrganizationModelSelector, builder) }
}
export function selectFromOwner() {
  return new OwnerModelSelector()
}

export const ownerModelPrimitives = selectFromOwner().name",
    true,
  ],
  Array [
    "UserModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * UserBase
 * auto generated base class for the model UserModel.
 */
export const UserModelBase = ModelBase
  .named('User')
  .props({
    __typename: types.optional(types.literal(\\"User\\"), \\"User\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    avatar: types.union(types.undefined, types.string),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class UserModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get avatar() { return this.__attr(\`avatar\`) }
}
export function selectFromUser() {
  return new UserModelSelector()
}

export const userModelPrimitives = selectFromUser().name.avatar
",
    true,
  ],
  Array [
    "UserModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { UserModelBase } from \\"./UserModel.base\\"

/* The TypeScript type of an instance of UserModel */
export interface UserModelType extends Instance<typeof UserModel.Type> {}

/* A graphql query fragment builders for UserModel */
export { selectFromUser, userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"

/**
 * UserModel
 */
export const UserModel = UserModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "OrganizationModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * OrganizationBase
 * auto generated base class for the model OrganizationModel.
 */
export const OrganizationModelBase = ModelBase
  .named('Organization')
  .props({
    __typename: types.optional(types.literal(\\"Organization\\"), \\"Organization\\"),
    id: types.identifier,
    name: types.union(types.undefined, types.string),
    logo: types.union(types.undefined, types.string),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class OrganizationModelSelector extends QueryBuilder {
  get id() { return this.__attr(\`id\`) }
  get name() { return this.__attr(\`name\`) }
  get logo() { return this.__attr(\`logo\`) }
}
export function selectFromOrganization() {
  return new OrganizationModelSelector()
}

export const organizationModelPrimitives = selectFromOrganization().name.logo
",
    true,
  ],
  Array [
    "OrganizationModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { OrganizationModelBase } from \\"./OrganizationModel.base\\"

/* The TypeScript type of an instance of OrganizationModel */
export interface OrganizationModelType extends Instance<typeof OrganizationModel.Type> {}

/* A graphql query fragment builders for OrganizationModel */
export { selectFromOrganization, organizationModelPrimitives, OrganizationModelSelector } from \\"./OrganizationModel.base\\"

/**
 * OrganizationModel
 */
export const OrganizationModel = OrganizationModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { RepoModel, RepoModelType } from \\"./RepoModel\\"
import { repoModelPrimitives, RepoModelSelector } from \\"./RepoModel.base\\"
import { UserModel, UserModelType } from \\"./UserModel\\"
import { userModelPrimitives, UserModelSelector } from \\"./UserModel.base\\"
import { OrganizationModel, OrganizationModelType } from \\"./OrganizationModel\\"
import { organizationModelPrimitives, OrganizationModelSelector } from \\"./OrganizationModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  repos: ObservableMap<string, RepoModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['Repo', () => RepoModel], ['User', () => UserModel], ['Organization', () => OrganizationModel]], ['Repo']))
  .props({
    repos: types.optional(types.map(types.late((): any => RepoModel)), {})
  })
  .actions(self => ({
    queryRepo(variables?: {  }, resultSelector: string | ((qb: RepoModelSelector) => RepoModelSelector) = repoModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ repo: RepoModelType}>(\`query repo { repo {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new RepoModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./RepoModel\\"
export * from \\"./OwnerModelSelector\\"
export * from \\"./UserModel\\"
export * from \\"./OrganizationModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;

exports[`union field type to work 1`] = `
Array [
  Array [
    "ModelBase",
    "import { MSTGQLObject } from \\"mst-gql\\"

export const ModelBase = MSTGQLObject
",
    false,
  ],
  Array [
    "SearchResultModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { BookModel } from \\"./BookModel\\"
import { MovieModel } from \\"./MovieModel\\"
import { SearchItemModelSelector } from \\"./SearchItemModelSelector\\"
import { RootStoreType } from \\"./index\\"


/**
 * SearchResultBase
 * auto generated base class for the model SearchResultModel.
 */
export const SearchResultModelBase = ModelBase
  .named('SearchResult')
  .props({
    __typename: types.optional(types.literal(\\"SearchResult\\"), \\"SearchResult\\"),
    inputQuery: types.union(types.undefined, types.string),
    items: types.union(types.undefined, types.array(types.union(types.null, types.union(types.late(() => MovieModel), types.late(() => BookModel))))),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class SearchResultModelSelector extends QueryBuilder {
  get inputQuery() { return this.__attr(\`inputQuery\`) }
  items(builder?: string | SearchItemModelSelector | ((selector: SearchItemModelSelector) => SearchItemModelSelector)) { return this.__child(\`items\`, SearchItemModelSelector, builder) }
}
export function selectFromSearchResult() {
  return new SearchResultModelSelector()
}

export const searchResultModelPrimitives = selectFromSearchResult().inputQuery
",
    true,
  ],
  Array [
    "SearchResultModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { SearchResultModelBase } from \\"./SearchResultModel.base\\"

/* The TypeScript type of an instance of SearchResultModel */
export interface SearchResultModelType extends Instance<typeof SearchResultModel.Type> {}

/* A graphql query fragment builders for SearchResultModel */
export { selectFromSearchResult, searchResultModelPrimitives, SearchResultModelSelector } from \\"./SearchResultModel.base\\"

/**
 * SearchResultModel
 */
export const SearchResultModel = SearchResultModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "SearchItemModelSelector",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { QueryBuilder } from \\"mst-gql\\"
import { BookModelSelector, bookModelPrimitives } from \\"./BookModel.base\\"
import { MovieModelSelector, movieModelPrimitives } from \\"./MovieModel.base\\"

export class SearchItemModelSelector extends QueryBuilder {
  movie(builder?: string | MovieModelSelector | ((selector: MovieModelSelector) => MovieModelSelector)) { return this.__inlineFragment(\`Movie\`, MovieModelSelector, builder) }
  book(builder?: string | BookModelSelector | ((selector: BookModelSelector) => BookModelSelector)) { return this.__inlineFragment(\`Book\`, BookModelSelector, builder) }
}
export function selectFromSearchItem() {
  return new SearchItemModelSelector()
}

// provides all primitive fields of union member types combined together
export const searchItemModelPrimitives = selectFromSearchItem().movie(movieModelPrimitives).book(bookModelPrimitives)",
    true,
  ],
  Array [
    "MovieModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * MovieBase
 * auto generated base class for the model MovieModel.
 */
export const MovieModelBase = ModelBase
  .named('Movie')
  .props({
    __typename: types.optional(types.literal(\\"Movie\\"), \\"Movie\\"),
    description: types.union(types.undefined, types.string),
    director: types.union(types.undefined, types.string),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class MovieModelSelector extends QueryBuilder {
  get description() { return this.__attr(\`description\`) }
  get director() { return this.__attr(\`director\`) }
}
export function selectFromMovie() {
  return new MovieModelSelector()
}

export const movieModelPrimitives = selectFromMovie().description.director
",
    true,
  ],
  Array [
    "MovieModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { MovieModelBase } from \\"./MovieModel.base\\"

/* The TypeScript type of an instance of MovieModel */
export interface MovieModelType extends Instance<typeof MovieModel.Type> {}

/* A graphql query fragment builders for MovieModel */
export { selectFromMovie, movieModelPrimitives, MovieModelSelector } from \\"./MovieModel.base\\"

/**
 * MovieModel
 */
export const MovieModel = MovieModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "BookModel.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { types } from \\"mobx-state-tree\\"
import { QueryBuilder } from \\"mst-gql\\"
import { ModelBase } from \\"./ModelBase\\"
import { RootStoreType } from \\"./index\\"


/**
 * BookBase
 * auto generated base class for the model BookModel.
 */
export const BookModelBase = ModelBase
  .named('Book')
  .props({
    __typename: types.optional(types.literal(\\"Book\\"), \\"Book\\"),
    description: types.union(types.undefined, types.string),
    author: types.union(types.undefined, types.string),
  })
  .views(self => ({
    get store() {
      return self.__getStore<RootStoreType>()
    }
  }))

export class BookModelSelector extends QueryBuilder {
  get description() { return this.__attr(\`description\`) }
  get author() { return this.__attr(\`author\`) }
}
export function selectFromBook() {
  return new BookModelSelector()
}

export const bookModelPrimitives = selectFromBook().description.author
",
    true,
  ],
  Array [
    "BookModel",
    "import { Instance } from \\"mobx-state-tree\\"
import { BookModelBase } from \\"./BookModel.base\\"

/* The TypeScript type of an instance of BookModel */
export interface BookModelType extends Instance<typeof BookModel.Type> {}

/* A graphql query fragment builders for BookModel */
export { selectFromBook, bookModelPrimitives, BookModelSelector } from \\"./BookModel.base\\"

/**
 * BookModel
 */
export const BookModel = BookModelBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore",
    "import { Instance } from \\"mobx-state-tree\\"
import { RootStoreBase } from \\"./RootStore.base\\"

export interface RootStoreType extends Instance<typeof RootStore.Type> {}

export const RootStore = RootStoreBase
  .actions(self => ({
    // This is an auto-generated example action.
    log() {
      console.log(JSON.stringify(self))
    }
  }))
",
    false,
  ],
  Array [
    "RootStore.base",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */
import { ObservableMap } from \\"mobx\\"
import { types } from \\"mobx-state-tree\\"
import { MSTGQLStore, configureStoreMixin, QueryOptions, withTypedRefs } from \\"mst-gql\\"

import { SearchResultModel, SearchResultModelType } from \\"./SearchResultModel\\"
import { searchResultModelPrimitives, SearchResultModelSelector } from \\"./SearchResultModel.base\\"
import { MovieModel, MovieModelType } from \\"./MovieModel\\"
import { movieModelPrimitives, MovieModelSelector } from \\"./MovieModel.base\\"
import { BookModel, BookModelType } from \\"./BookModel\\"
import { bookModelPrimitives, BookModelSelector } from \\"./BookModel.base\\"


/* The TypeScript type that explicits the refs to other models in order to prevent a circular refs issue */
type Refs = {
  searchresults: ObservableMap<string, SearchResultModelType>
}

/**
* Store, managing, among others, all the objects received through graphQL
*/
export const RootStoreBase = withTypedRefs<Refs>()(MSTGQLStore
  .named(\\"RootStore\\")
  .extend(configureStoreMixin([['SearchResult', () => SearchResultModel], ['Movie', () => MovieModel], ['Book', () => BookModel]], ['SearchResult']))
  .props({
    searchresults: types.optional(types.map(types.late((): any => SearchResultModel)), {})
  })
  .actions(self => ({
    querySearch(variables: { text: string }, resultSelector: string | ((qb: SearchResultModelSelector) => SearchResultModelSelector) = searchResultModelPrimitives.toString(), options: QueryOptions = {}) {
      return self.query<{ search: SearchResultModelType}>(\`query search($text: String!) { search(text: $text) {
        \${typeof resultSelector === \\"function\\" ? resultSelector(new SearchResultModelSelector()).toString() : resultSelector}
      } }\`, variables, options)
    },
  })))
",
    true,
  ],
  Array [
    "reactUtils",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

import { createStoreContext, createUseQueryHook } from \\"mst-gql\\"
import * as React from \\"react\\"
import { RootStore, RootStoreType } from \\"./RootStore\\"

export const StoreContext = createStoreContext<RootStoreType>(React)

export const useQuery = createUseQueryHook(StoreContext, React)
",
    true,
  ],
  Array [
    "index",
    "/* This is a mst-gql generated file, don't modify it manually */
/* eslint-disable */
/* tslint:disable */

export * from \\"./SearchResultModel\\"
export * from \\"./SearchItemModelSelector\\"
export * from \\"./MovieModel\\"
export * from \\"./BookModel\\"
export * from \\"./RootStore\\"
export * from \\"./reactUtils\\"
",
    true,
  ],
]
`;
